

from math import floor
from numpy import array, zeros, random, single, int64
# from pprint import pp
# import cProfile

import AutoPlayUtilsPy
import AutoPlayUtilsCy

SIZE = int(4)

# !!! Important configuration flag. Determines if UtilsPy or UtilsCy is used,
# with a huge impact on execution speed.
USE_CYTHON = True


# ****************************************
class AutoPlayer:
    #6, 7
    def __init__(self, game, tree_depth=6, topx_perc=0.05, calc_option=3, rand=None):

        # GameMgr.Game object stores current game state: tiles, score, etc
        self.game = game

        # self.move_tree = None
        self.tree_depth = tree_depth
        self.tree_size = 0
        self.topx_perc = topx_perc
        self.calc_option = calc_option

        # If Cython is used, then Autoplay must contain random numbers.
        # MUCH faster to generate random numbers upfront w/NumPy vs. on the fly
        # self.rand_idx must be incremented each time one is used.
        if USE_CYTHON:

            # Enable optional passing of fixed seed NumPy number generator for testing
            if rand is None:
                self.rand = random.default_rng()
            else:
                self.rand = rand

            # Calculate how many random numbers are needed based on move tree size
            rand_nums = int(sum([4**i for i in range(tree_depth+1)])*2*4000)
            self.rands = self.rand.random(rand_nums, dtype=single)
            self.rand_idx = int(0)

            # # DEBUG
            # print(f"Length(self.rands) = {self.rands.shape}  dtype = {self.rands.dtype}")

        # If Cython is NOT used, (speed not critical)
        # then AutoPlay does not need to contain random numbers
        # Rands will be generated by GameMgr.Game.rand
        else:
            self.rand = None

        # DEBUG
        self.move_metrics = []
        self.best_move = 0
        self.last_move_valid = False

    def __repr__(self):
        out = list()
        out.append("-"*30 + "\n")
        out.append(f"AutoPlay - Tree Depth: {self.tree_depth} | " +
                   f"TopX: {self.topx_perc}%, {floor(self.tree_size*self.topx_perc)} | Calc: {self.calc_option} | " +
                   f"Rands Length: {self.rands.size} | rand_idx: {self.rand_idx}\n")
        out.append(repr(self.game))

        return "".join(out)

    def get_move(self):

        self.tree_size = 0
        move_tree = MoveNode(None, self.game.tiles, self.game.score, self)

        # DEBUG
        # print_tree_bfs(move_tree)

        move_metrics = list()

        # Search "forward" in move tree
        # Record the "max metric" found in tree below each "move_score[i]"
        # move_dir=0: Up, move_dir=1: Right, move_dir=2: Down, move_dir=3: Left
        for move_dir in range(SIZE):

            # If this was an invalid move (no node exists), metric is -2
            if move_tree.next[move_dir] is None:
                move_metrics.append(-2.0)
                continue

            # If this move would displace a max from a corner, metric is -1
            if move_tree.metric > 0 and move_tree.next[move_dir].metric == 0:
                move_metrics.append(-1.0)
                continue

            # Experiments indicate top ~?% averaged yields best results
            topx_num = max(1, floor(self.tree_size*self.topx_perc))
            max_metrics = zeros(topx_num, dtype=int64)
            max_metrics[-1] = move_tree.next[move_dir].metric
            max_metrics = AutoPlayUtilsPy.node_tree_max_DFS(move_tree.next[move_dir], max_metrics)
            move_metrics.append(max_metrics.sum() / float(topx_num))

        # # DEBUG
        # print(f"move_metrics: Up: {move_metrics[0]}, Right: {move_metrics[1]}, " +
        #       f"Down: {move_metrics[2]}, Left: {move_metrics[3]}")

        # Very important...multiple metrics can be the same (usually 0)
        # In this case you must find a valid move to return (not the default "0" - Up)
        max_met = max(move_metrics)
        maxs = [(i, move_metrics[i]) for i in range(4) if move_metrics[i] == max_met]

        # If only one max return its move,
        # or if there is no good move (max metrics are zero) pick any of them.
        if len(maxs) == 1 or max_met == 0:
            best_move = move_metrics.index(max_met)

        # If there is more than one equally good move
        else:
            print(f"MORE THAN ONE BEST MOVE: move_metrics = {move_metrics}")
            best_move = move_metrics.index(max_met)

        # DEBUG
        self.move_metrics = move_metrics
        self.best_move = best_move

        return best_move

    def auto_move(self):

        if self.game.game_over:
            return

        best_move = self.get_move()

        # # DEBUG
        # options = ["Up", "Right", "Down", "Left"]
        # print(f"Best Move: {options[best_move]}")
        # ans = input("Continue? ")
        # if ans in ["N", "n"]:
        #     quit()

        if USE_CYTHON:
            valid_move, tiles2, self.game.score = \
                AutoPlayUtilsCy.move_tiles(best_move, self.game.tiles, self.game.score)
        else:
            valid_move, _, _, _ = self.game.move_tiles(best_move, True)

        if valid_move:
            if USE_CYTHON:
                self.game.tiles, self.game.num_empty, self.rand_idx = \
                    AutoPlayUtilsCy.add_random_tile(tiles2, self.rands, self.rand_idx)
                self.game.num_moves += 1

                if self.game.num_empty == 0:
                    self.game.game_over = self.game.check_game_over(self.game.tiles)
            else:
                self.game.add_random_tile(commit=True)

        # if not valid_move and self.game.num_empty == 0:
        #     self.game.game_over = True

        # DEBUG
        self.last_move_valid = valid_move

        return valid_move


# ****************************************
# Nodes of individual game state
# Linked to form a 4-ary Tree structure
# of all likely future game states after "tree_depth" moves
class MoveNode:

    # Initializes Node AND
    # Recursively builds 4-ary tree to "TREE_DEPTH"
    def __init__(self, prev, tiles, score, ap):

        # self.tiles = tiles.copy()
        self.prev = prev
        self.score = score
        self.level = 0 if (prev is None) else (prev.level + 1)
        self.metric = 0

        if USE_CYTHON:  # Use fast Cython functions
            if ap.calc_option == 0:
                self.metric = AutoPlayUtilsCy.calc_metrics0(tiles)
            elif ap.calc_option == 1:
                self.metric = AutoPlayUtilsCy.calc_metrics1(tiles)
            elif ap.calc_option == 2:
                self.metric = AutoPlayUtilsCy.calc_metrics2(tiles)
            elif ap.calc_option == 3:
                self.metric, _ = AutoPlayUtilsCy.calc_metrics3(tiles)

        else:   # Use slower Python functions
            if ap.calc_option == 0:
                self.metric = AutoPlayUtilsPy.calc_metrics0(tiles)
            elif ap.calc_option == 1:
                self.metric = AutoPlayUtilsPy.calc_metrics1(tiles)
            elif ap.calc_option == 2:
                self.metric = AutoPlayUtilsPy.calc_metrics2(tiles)
            elif ap.calc_option == 3:
                self.metric = AutoPlayUtilsPy.calc_metrics3(tiles)

        # Base Case: If already traversed to proper tree depth, stop
        if self.level > ap.tree_depth - 1:
            self.next = None
            return

        # Recursively build next level of tree
        else:
            self.next = []

            # Children Moves: 0 - Up, 1 - Right, 2 - Down, 3 - Left
            for direction in range(4):

                # Move Tiles
                if USE_CYTHON:
                    valid_move, new_tiles, new_score = \
                        AutoPlayUtilsCy.move_tiles(direction, tiles, score)
                else:
                    valid_move, _, new_tiles, new_score = \
                        ap.game.move_tiles(direction, False, tiles, score)

                # If valid move, add random tile
                if valid_move:

                    if USE_CYTHON:
                        new_tiles, _, ap.rand_idx = \
                            AutoPlayUtilsCy.add_random_tile(new_tiles, ap.rands, ap.rand_idx)
                    else:
                        new_tiles, _, _, ap.rand_idx = \
                            ap.game.add_random_tile(commit=False, tiles=new_tiles)

                    ap.tree_size += 1

                    self.next.append(MoveNode(self, new_tiles, new_score, ap))

                else:
                    self.next.append(None)

    def __repr__(self):

        out = list()
        out.append("-"*20 + "\n")
        out.append(f"Tree Level: {self.level}  |  Score: {self.score}")
        out.append(f"  |  Metric: {self.metric}\n")

        return "".join(out)


if __name__ == '__main__':

    print("This file is not designed to be run on its own.")
    # tiles1 = [[0, 2, 2, 4],
    #          [0, 4, 4, 8],
    #          [0, 8, 8, 16],
    #          [16, 32, 32, 2048]]
    #
    # AutoPlayUtilsCy.calc_metrics1(array(tiles1))

    # import GameMgr

    # game1 = GameMgr.Game(None, None, 0)
    # game1.add_random_tile(commit=True)
    # ap = AutoPlayer(game1, tree_depth=5)
    # ap.auto_move()




